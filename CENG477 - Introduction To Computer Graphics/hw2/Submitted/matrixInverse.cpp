#include <stdexcept>

/*
 * m represents a 4x4 matrix stored as a 1D array in row-major-order.
 * For instance m[6] represents the element at the second row third column
 * of the matrix. 
 *
 * inv contains the inverse of this matrix stored in the same
 * format as the input.
 */
void invert(float m[4][4], float inv[4][4])
{
    //
    // This code is taken from the GLU library 
    //    
    double det;

    inv[0][0] = m[1][1]  * m[2][2] * m[3][3] - 
        m[1][1]  * m[2][3] * m[3][2] - 
        m[2][1]  * m[1][2]  * m[3][3] + 
        m[2][1]  * m[1][3]  * m[3][2] +
        m[3][1] * m[1][2]  * m[2][3] - 
       m[3][1] * m[1][3]  * m[2][2];

    inv[1][0] = -m[1][0] * m[2][2] * m[3][3] + 
        m[1][0]  * m[2][3] * m[3][2] + 
      m[2][0]  * m[1][2]  * m[3][3] - 
       m[2][0]  * m[1][3] * m[3][2] - 
        m[3][0] * m[1][2]  *m[2][3] + 
        m[3][0] * m[1][3]  * m[2][2];

    inv[2][0] = m[1][0] * m[2][1] * m[3][3] - 
        m[1][0]  * m[2][3] * m[3][1] - 
       m[2][0] * m[1][1] *m[3][3]+ 
       m[2][0]  * m[1][3] * m[3][1] + 
        m[3][0] * m[1][1] * m[2][3] - 
        m[3][0] * m[1][3] * m[2][1];

    inv[3][0] = -m[1][0]  * m[2][1] * m[3][2] + 
        m[1][0] * m[2][2] * m[3][1] +
       m[2][0]  * m[1][1] * m[3][2] - 
       m[2][0]  * m[1][2] * m[3][1] - 
        m[3][0] * m[1][1] * m[2][2] + 
        m[3][0] * m[1][2] * m[2][1];

    inv[0][1] = -m[0][1]  * m[2][2] *m[3][3] + 
        m[0][1]  *m[2][3] * m[3][2] + 
        m[2][1]  * m[0][2] *m[3][3] - 
        m[2][1]  * m[0][3] * m[3][2]- 
        m[3][1] * m[0][2] * m[2][3] + 
        m[3][1] * m[0][3] * m[2][2];

    inv[1][1] =m[0][0]  * m[2][2] * m[3][3]- 
        m[0][0]  *m[2][3] * m[3][2] - 
       m[2][0]  * m[0][2] *m[3][3] + 
        m[2][0]  * m[0][3] * m[3][2] + 
        m[3][0] * m[0][2] * m[2][3] - 
        m[3][0] * m[0][3] * m[2][2];

    inv[2][1] = -m[0][0]  * m[2][1] * m[3][3] + 
        m[0][0]  *m[2][3] * m[3][1] + 
        m[2][0]  * m[0][1] * m[3][3] - 
       m[2][0]  * m[0][3] *m[3][1] - 
        m[3][0] * m[0][1]*m[2][3] + 
        m[3][0] * m[0][3] * m[2][1];

    inv[3][1] = m[0][0]  * m[2][1] * m[3][2] - 
        m[0][0]  * m[2][2] * m[3][1] - 
        m[2][0]  * m[0][1] * m[3][2] + 
        m[2][0]* m[0][2] * m[3][1] + 
        m[3][0] * m[0][1] * m[2][2] - 
        m[3][0] * m[0][2] * m[2][1];

    inv[0][2] = m[0][1]  * m[1][2] * m[3][3] - 
        m[0][1]  * m[1][3] * m[3][2]- 
        m[1][1]  * m[0][2] * m[3][3] + 
        m[1][1]  * m[0][3] * m[3][2] + 
       m[3][1] * m[0][2] * m[1][3] - 
        m[3][1] * m[0][3] * m[1][2];

    inv[1][2] = -m[0][0]  * m[1][2] * m[3][3] + 
        m[0][0]  * m[1][3] * m[3][2]+ 
        m[1][0]  * m[0][2] *m[3][3] - 
        m[1][0]  * m[0][3] * m[3][2] - 
        m[3][0] * m[0][2] * m[1][3]+ 
        m[3][0] * m[0][3] * m[1][2];

    inv[2][2] = m[0][0]  * m[1][1] * m[3][3] - 
        m[0][0]  *m[1][3]* m[3][1] - 
        m[1][0]  * m[0][1] * m[3][3] + 
       m[1][0]  * m[0][3] * m[3][1] + 
        m[3][0] * m[0][1] * m[1][3] - 
        m[3][0] * m[0][3] * m[1][1];

    inv[3][2] = -m[0][0]  * m[1][1] * m[3][2] + 
       m[0][0] * m[1][2] * m[3][1] + 
        m[1][0]  * m[0][1] * m[3][2] - 
        m[1][0]  * m[0][2] *m[3][1] - 
        m[3][0] * m[0][1] * m[1][2] + 
        m[3][0] * m[0][2] * m[1][1];

    inv[0][3] = -m[0][1] * m[1][2]*m[2][3] + 
        m[0][1] * m[1][3] * m[2][2] + 
        m[1][1] * m[0][2] *m[2][3] - 
        m[1][1] * m[0][3] * m[2][2] - 
        m[2][1] * m[0][2] * m[1][3] + 
        m[2][1] * m[0][3] * m[1][2];

    inv[1][3] = m[0][0] * m[1][2] * m[2][3] - 
        m[0][0] * m[1][3] * m[2][2] - 
       m[1][0] * m[0][2] * m[2][3] + 
        m[1][0] * m[0][3] * m[2][2] + 
       m[2][0] * m[0][2] * m[1][3] - 
       m[2][0] * m[0][3] * m[1][2];

    inv[2][3]= -m[0][0] * m[1][1] * m[2][3] + 
        m[0][0] * m[1][3] * m[2][1] + 
        m[1][0] * m[0][1] * m[2][3] - 
        m[1][0] * m[0][3] * m[2][1] - 
       m[2][0] * m[0][1] * m[1][3] + 
        m[2][0] * m[0][3] * m[1][1];

    inv[3][3] = m[0][0] * m[1][1] * m[2][2] - 
        m[0][0] * m[1][2] * m[2][1] - 
        m[1][0] * m[0][1] * m[2][2] + 
        m[1][0] * m[0][2] * m[2][1] + 
       m[2][0] * m[0][1] * m[1][2] - 
        m[2][0] * m[0][2] * m[1][1];

    det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];

    if (det == 0)
    {
        throw std::runtime_error("Error: Determinant is zero.");
    }

    det = 1.0 / det;

    for (int i = 0; i < 4; ++i)
    {
        for(int j=0;j<4;j++)
        inv[i][j] *= det;
    }
}
